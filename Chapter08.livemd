# Chapter Eight

```elixir
Mix.install([
  {:axon_onnx, "~> 0.4"},
  {:axon, "~> 0.6"},
  {:nx, "~> 0.6"},
  {:exla, "~> 0.6"},
  {:stb_image, "~> 0.6"},
  {:kino, "~> 0.11"},
  {:table_rex, "~> 3.1.1"}
])
```

## Dogs vs Cats (Again)

```elixir
Nx.global_default_backend(EXLA.Backend)
```

```elixir
defmodule CatsAndDogs do
  def pipeline(paths, batch_size, target_height, target_width) do
    paths
    |> Enum.shuffle()
    |> Task.async_stream(&parse_image/1)
    |> Stream.filter(fn
      {:ok, {%StbImage{}, _}} -> true
      _ -> false
    end)
    |> Stream.map(&to_tensors(&1, target_height, target_width))
    |> Stream.chunk_every(batch_size)
    |> Stream.map(fn chunks ->
      {img_chunk, label_chunk} = Enum.unzip(chunks)
      {Nx.stack(img_chunk), Nx.stack(label_chunk)}
    end)
  end

  def pipeline_with_augmentations(
        paths,
        batch_size,
        target_height,
        target_width
      ) do
    paths
    |> Enum.shuffle()
    |> Task.async_stream(&parse_image/1)
    |> Stream.filter(fn
      {:ok, {%StbImage{}, _}} -> true
      _ -> false
    end)
    |> Stream.map(&to_tensors(&1, target_height, target_width))
    |> Stream.map(&random_flip(&1, :height))
    |> Stream.map(&random_flip(&1, :width))
    |> Stream.chunk_every(batch_size)
    |> Stream.map(fn chunks ->
      {img_chunk, label_chunk} = Enum.unzip(chunks)
      {Nx.stack(img_chunk), Nx.stack(label_chunk)}
    end)
  end

  defp random_flip({image, label}, axis) do
    if :rand.uniform() < 0.5 do
      {Nx.reverse(image, axes: [axis]), label}
    else
      {image, label}
    end
  end

  defp parse_image(path) do
    label = if String.contains?(path, "cat"), do: 0, else: 1

    case StbImage.read_file(path) do
      {:ok, img} -> {img, label}
      _error -> :error
    end
  end

  defp to_tensors({:ok, {img, label}}, target_height, target_width) do
    img_tensor =
      img
      |> StbImage.resize(target_height, target_width)
      |> StbImage.to_nx()
      |> Nx.divide(255)
      |> Nx.transpose(axes: [:channels, :height, :width])

    label_tensor = Nx.tensor([label])
    {img_tensor, label_tensor}
  end
end
```

```elixir
train_paths =
  Path.wildcard("Data/DogsVCats/Train/*.jpg")
  |> Enum.shuffle()

{test_paths, validation_paths} =
  Path.wildcard("Data/DogsVCats/Test/*.jpg")
  |> Enum.shuffle()
  |> Enum.split(10_000)

batch_size = 32
target_height = 160
target_width = 160

train_pipeline =
  CatsAndDogs.pipeline_with_augmentations(
    train_paths,
    batch_size,
    target_height,
    target_width
  )

validation_pipeline =
  CatsAndDogs.pipeline(
    validation_paths,
    batch_size,
    target_height,
    target_width
  )

test_pipeline =
  CatsAndDogs.pipeline(
    test_paths,
    batch_size,
    target_height,
    target_width
  )

train_paths |> Enum.count() |> IO.inspect(label: "training dataset size")
test_paths |> Enum.count() |> IO.inspect(label: "test dataset size")
validation_paths |> Enum.count() |> IO.inspect(label: "validation dataset size")

:ok
```

## ONNX

```elixir
{cnn_base, cnn_base_params} =
  AxonOnnx.import(
    "Data/MobileNet/mobilenetv2-7.onnx",
    batch_size: batch_size
  )
```

```elixir
input_template = Nx.template({1, 3, target_height, target_width}, :f32)
# Axon.Display.as_graph(cnn_base, input_template)
```

```elixir
{_popped, cnn_base} = cnn_base |> Axon.pop_node()
{_popped, cnn_base} = cnn_base |> Axon.pop_node()
# Axon.Display.as_graph(cnn_base, input_template)

model =
  cnn_base
  |> Axon.namespace("feature_extractor")
  |> Axon.freeze()
  |> Axon.global_avg_pool(channels: :first)
  |> Axon.dropout(rate: 0.2)
  |> Axon.dense(1)
```

```elixir
trained_model_state =
  model
  |> Axon.Loop.trainer(
    &Axon.Losses.binary_cross_entropy(&1, &2, reduction: :mean, from_logits: true),
    Axon.Optimizers.adam(1.0e-4)
  )
  |> Axon.Loop.metric(:accuracy)
  |> Axon.Loop.validate(model, validation_pipeline)
  |> Axon.Loop.early_stop("validation_loss", mode: :min, patience: 5)
  |> Axon.Loop.run(
    train_pipeline,
    %{"feature_extractor" => cnn_base_params},
    epochs: 100,
    compiler: EXLA
  )
```
