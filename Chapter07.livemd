# Chapter Seven

```elixir
Mix.install([
  {:nx, "~> 0.6"},
  {:axon, "~> 0.6"},
  {:exla, "~> 0.6"},
  {:stb_image, "~> 0.6"},
  {:kino, "~> 0.11"},
  {:table_rex, "~> 3.1.1"}
])
```

## Pipeline

```elixir
defmodule CatsAndDogs do
  def pipeline(paths, batch_size, target_height, target_width) do
    paths
    |> Enum.shuffle()
    |> Task.async_stream(&parse_image/1)
    |> Stream.filter(fn
      {:ok, {%StbImage{}, _}} -> true
      _ -> false
    end)
    |> Stream.map(&to_tensors(&1, target_height, target_width))
    # |> Stream.map(&regularize/1)
    |> Stream.chunk_every(batch_size, batch_size, :discard)
    |> Stream.map(fn chunks ->
      {image_chunk, label_chunk} = Enum.unzip(chunks)
      {Nx.stack(image_chunk), Nx.stack(label_chunk)}
    end)
  end

  def pipeline_with_augmentations(paths, batch_size, target_height, target_width) do
    paths
    |> Enum.shuffle()
    |> Task.async_stream(&parse_image/1)
    |> Stream.filter(fn
      {:ok, {%StbImage{}, _}} -> true
      _ -> false
    end)
    |> Stream.map(&to_tensors(&1, target_height, target_width))
    |> Stream.map(&random_flip(&1, :height))
    |> Stream.map(&random_flip(&1, :width))
    |> Stream.chunk_every(batch_size, batch_size, :discard)
    |> Stream.map(fn chunks ->
      {img_chunk, label_chunk} = Enum.unzip(chunks)
      {Nx.stack(img_chunk), Nx.stack(label_chunk)}
    end)
  end

  defp parse_image(path) do
    label = if String.contains?(path, "cat"), do: 0, else: 1

    case StbImage.read_file(path) do
      {:ok, img} -> {img, label}
      _error -> :error
    end
  end

  defp random_flip({image, label}, axis) do
    {do_random_flip(image, axis, :rand.uniform()), label}
  end

  defp do_random_flip(image, axis, odds) when odds > 0.5 do
    Nx.reverse(image, axes: [axis])
  end

  defp do_random_flip(image, _, _), do: image
  # defp regularize(tensor), do: Nx.divide(tensor, 255)

  defp to_tensors({:ok, {image, label}}, target_height, target_width) do
    image_tensor =
      image
      |> StbImage.resize(target_height, target_width)
      |> StbImage.to_nx()
      |> Nx.divide(255)

    label_tensor = Nx.tensor([label])

    {image_tensor, label_tensor}
  end
end

:ok
```

```elixir
train_paths =
  Path.wildcard("Chapter07/train/*.jpg")
  |> Enum.shuffle()

{test_paths, validation_paths} =
  Path.wildcard("Chapter07/test*/*.jpg")
  |> Enum.shuffle()
  |> Enum.split(10_000)
```

```elixir
{test_paths, train_paths} =
  Path.wildcard("Chapter07/train/*.jpg")
  |> Enum.shuffle()
  |> Enum.split(1_000)

batch_size = 64
target_height = 96
target_width = 96

train_pipeline =
  train_paths
  |> CatsAndDogs.pipeline_with_augmentations(batch_size, target_height, target_width)

test_pipeline =
  test_paths
  |> CatsAndDogs.pipeline(batch_size, target_height, target_width)

validation_pipeline =
  validation_paths
  |> CatsAndDogs.pipeline(batch_size, target_height, target_width)

# train_pipeline |> Enum.take(1) |> IO.inspect(label: "train item")
# test_pipeline |> Enum.take(1) |> IO.inspect(label: "test item")
# validation_pipeline |> Enum.take(1) |> IO.inspect(label: "validation item")

train_paths |> Enum.count() |> IO.inspect(label: "training dataset size")
test_paths |> Enum.count() |> IO.inspect(label: "test dataset size")
validation_paths |> Enum.count() |> IO.inspect(label: "validation dataset size")

:ok
```

## Multi Layer Perceptron

```elixir
mlp_model =
  Axon.input("images", shape: {nil, target_height, target_width, 3})
  |> Axon.flatten()
  |> Axon.dense(256, activation: :relu)
  |> Axon.dense(128, activation: :relu)
  |> Axon.dense(1, activation: :sigmoid)
```

```elixir
mlp_template = Nx.template({1, 27648}, :f32)
Axon.Display.as_table(mlp_model, mlp_template) |> IO.puts()
```

### Train MLP

```elixir
# mlp_trained_model_state =
#  mlp_model
#  |> Axon.Loop.trainer(:binary_cross_entropy, :adam)
#  |> Axon.Loop.metric(:accuracy)
#  |> Axon.Loop.run(train_pipeline, %{}, epochs: 5, compiler: EXLA)
```

### Seiralize Trained Model State

Serialize a model and parameters after training. Desirialize the saved model and parameters to save time in the future.

```elixir
path = "Chapter07/multi_layer_perceptron_state.axon"

# mlp_trained_model_state
# |> Nx.serialize()
# |> then(&File.write!(path, &1))

mlp_trained_model_state = File.read!(path) |> Nx.deserialize()
```

```elixir
mlp_model
|> Axon.Loop.evaluator()
|> Axon.Loop.metric(:accuracy)
|> Axon.Loop.run(test_pipeline, mlp_trained_model_state, compiler: EXLA)
```

## Convolution

```elixir
random_dog_image_path = "Chapter07/train/dog.#{:rand.uniform(1_000)}.jpg"

original_dog_image =
  random_dog_image_path
  |> StbImage.read_file!()
  |> StbImage.to_nx()

original_dog_image |> Kino.Image.new()
```

```elixir
prepared_dog_image =
  original_dog_image
  |> Nx.transpose(axes: [:channels, :height, :width])
  |> Nx.new_axis(0)

kernel =
  Nx.tensor([
    [-1, 0, 1],
    [-1, 0, 1],
    [-1, 0, 1]
  ])

kernel = kernel |> Nx.reshape({1, 1, 3, 3}) |> Nx.broadcast({3, 3, 3, 3})

prepared_dog_image
|> Nx.conv(kernel)
|> Nx.as_type({:u, 8})
|> Nx.squeeze(axes: [0])
|> Nx.transpose(axes: [:height, :width, :channels])
|> Kino.Image.new()
```

## Convolutional Neural Network

```elixir
cnn_model =
  Axon.input("images", shape: {nil, 96, 96, 3})
  |> Axon.conv(32, kernel_size: {3, 3}, padding: :same, activation: :relu)
  |> Axon.max_pool(kernel_size: {2, 2}, strides: [2, 2])
  |> Axon.conv(64, kernel_size: {3, 3}, padding: :same, activation: :relu)
  |> Axon.max_pool(kernel_size: {2, 2}, strides: [2, 2])
  |> Axon.conv(128, kernel_size: {3, 3}, padding: :same, activation: :relu)
  |> Axon.max_pool(kernel_size: {2, 2}, strides: [2, 2])
  |> Axon.flatten()
  |> Axon.dense(128, activation: :relu)
  |> Axon.dense(1, activation: :sigmoid)
```

```elixir
cnn_template = Nx.template({1, 96, 96, 3}, :f32)
Axon.Display.as_table(cnn_model, cnn_template) |> IO.puts()
```

```elixir
# cnn_trained_model_state =
<<<<<<< HEAD
#   cnn_model
#   |> Axon.Loop.trainer(:binary_cross_entropy, :adam)
#   |> Axon.Loop.metric(:accuracy)
#   |> Axon.Loop.run(train_pipeline, %{}, epochs: 5, compiler: EXLA)
=======
#  cnn_model
#  |> Axon.Loop.trainer(:binary_cross_entropy, :adam)
#  |> Axon.Loop.metric(:accuracy)
#  |> Axon.Loop.run(train_pipeline, %{}, epochs: 5, compiler: EXLA)
>>>>>>> 5739aafbfef00c50b7d218c1725cec71d2b73a86
```

```elixir
path = "Chapter07/convolutional_neural_network_state.axon"

# cnn_trained_model_state
# |> Nx.serialize()
# |> then(&File.write!(path, &1))

cnn_trained_model_state = File.read!(path) |> Nx.deserialize()
```

```elixir
# cnn_model
# |> Axon.Loop.evaluator()
# |> Axon.Loop.metric(:accuracy)
# |> Axon.Loop.run(test_pipeline, cnn_trained_model_state, compiler: EXLA)
```

## Improved Convolutional Neural Network

```elixir
improved_cnn_model =
  Axon.input("images", shape: {nil, 96, 96, 3})
  |> Axon.conv(32, kernel_size: {3, 3}, activation: :relu, padding: :same)
  |> Axon.batch_norm()
  |> Axon.max_pool(kernel_size: {2, 2}, strides: [2, 2])
  |> Axon.conv(64, kernel_size: {3, 3}, activation: :relu, padding: :same)
  |> Axon.batch_norm()
  |> Axon.max_pool(kernel_size: {2, 2}, strides: [2, 2])
  |> Axon.conv(128, kernel_size: {3, 3}, activation: :relu, padding: :same)
  |> Axon.max_pool(kernel_size: {2, 2}, strides: [2, 2])
  |> Axon.flatten()
  |> Axon.dense(128, activation: :relu)
  |> Axon.dropout(rate: 0.25)
  |> Axon.dense(1, activation: :sigmoid)
```

```elixir
Axon.Display.as_table(improved_cnn_model, cnn_template) |> IO.puts()
```

```elixir
# improved_cnn_trained_model_state =
#   cnn_model
#   |> Axon.Loop.trainer(:binary_cross_entropy, Axon.Optimizers.adam(1.0e-3))
#   |> Axon.Loop.metric(:accuracy)
#   |> Axon.Loop.validate(cnn_model, validation_pipeline)
#   |> Axon.Loop.early_stop("validation_loss", mode: :min)
#   |> Axon.Loop.run(train_pipeline, %{}, epochs: 100, compiler: EXLA)
```

```elixir
path = "Chapter07/improved_convolutional_neural_network_state.axon"

# cnn_trained_model_state
# |> Nx.serialize()
# |> then(&File.write!(path, &1))

improved_cnn_trained_model_state = File.read!(path) |> Nx.deserialize()
```

```elixir
cnn_model
|> Axon.Loop.evaluator()
|> Axon.Loop.metric(:accuracy)
|> Axon.Loop.run(test_pipeline, improved_cnn_trained_model_state, compiler: EXLA)
```
